---
title: 逻辑回归-学习笔记
date: 2017-08-13
tags: [AI]
categories: 机器学习
---

# 逻辑回归-学习笔记 

学习任何东西都可以按照3W的框架进行，容器技术也是一样，先回答 What、Why 和 How 这三个问题。

## 参考
* [逻辑回归原理](http://www.cnblogs.com/pinard/p/6029432.html)
* [逻辑回归](http://m.blog.csdn.net/pakko/article/details/37878837)
* [Fun with Logistic Regression.ipynb](https://gist.github.com/vietjtnguyen/6655020)

# 概述
辑回归是一个分类算法，它可以处理二元分类以及多元分类。
虽然它名字里面有“回归”两个字，却不是一个回归算法。
那为什么有“回归”这个误导性的词呢？
个人认为，虽然逻辑回归是分类模型，但是它的原理里面却残留着回归模型的影子，

## 从线性回归到逻辑回归
线性回归的模型是求出`输出特征向量Y`和`输入样本矩阵X`之间的`线性关系系数θ`，满足$Y=X 	heta$。
此时我们的$Y$是连续的，所以是回归模型。
如果我们想要$Y$是离散的话，怎么办呢？我们对于Y再做一次函数转换，变为$g(Y)$。
>如果我们令$g(Y)$的值在某个实数区间的时候是类别A，在另一个实数区间的时候是类别B，以此类推，就得到了一个分类模型。如果结果的类别只有两种，那么就是一个二元分类模型了。
逻辑回归的出发点就是从这来的。


# 二元逻辑回归的模型
对线性回归的结果做一个在函数g上的转换，可以变化为逻辑回归。
这个函数g在逻辑回归中我们一般取为sigmoid函数，形式如下：
$$ g(z) = rac {1} {1+e^{-z}}  $$

### 模型性质
1. 当z趋于正无穷时，g(z)趋于1；当z趋于负无穷时，g(z)趋于0（这非常适合分类概率模型）
2. 对g(z)求导可得到：$g′(z)=g(z)(1−g(z))  $，如果令g(z)中的z为：$z=xθ$，这样就得到了二元逻辑回归模型的一般形式：
$$ h_{	heta}(x) = rac {1} {1+e^{-x	heta}}  $$
其中$x$为样本输入，$h_	heta(x)$为模型输出，可以理解为某一分类的概率大小。而$θ$为分类模型的要求出的模型参数。
对于模型输出$h_	heta(x)$，我们让它和我们的二元样本输出$y$（假设为0和1）有这样的对应关系，
如果$h_	heta(x)>0.5 $，即$x_	heta>0$, 则$y$为1。
如果$h_	heta(x)<0.5$，即$x_	heta<0$, 则$y$为0。
$y=0.5$是临界情况，此时$x_	heta=0$， 从逻辑回归模型本身无法确定分类。

>$h_	heta(x)$的值越小，而分类为0的的概率越高，反之，值越大的话分类为1的的概率越高。
>如果靠近临界点，则分类准确率会下降。

3. 模型的矩阵模式：
$$ h_{	heta}(X) = rac {1} {1+e^{-X	heta}}  $$
其中$h_	heta(x)$为模型输出，为$m*1$的维度。$X$为样本特征矩阵，为$m*n$的维度。$	heta$为分类的模型系数，为$n*1$的向量。

理解了二元分类回归的模型，就要看模型的损失函数，我们的目标是极小化损失函数来得到对应的模型系数$	heta$。

#  二元逻辑回归的损失函数
由于线性回归是连续的，所以可以使用`模型误差的的平方和`来定义损失函数。
但是逻辑回归不是连续的，自然线性回归损失函数定义的经验就用不上了。
不过我们可以用`最大似然法`来推导出我们的损失函数。

按照二元逻辑回归的定义，假设我们的样本输出是0或者1两类。那么我们有：
$$P(y=1|x,	heta ) = h_{	heta}(x)$$
$$P(y=0|x,	heta ) = 1- h_{	heta}(x)$$

把这两个式子写成一个式子：$$ P(y|x,	heta ) = h_{	heta}(x)^y(1-h_{	heta}(x))^{1-y}$$
其中$y$的取值只能是0或者1。
用矩阵法表示，即为：$$P(Y|X,	heta ) = h_{	heta}(X)^Y(E-h_{	heta}(X))^{1-Y}$$
其中$E$为单位矩阵。
得到了$y$的概率分布函数表达式，我们就可以用`似然函数最大化`来求解我们需要的模型系数$	heta$。
为了方便求解，这里我们用对数似然函数最大化，对数似然函数取反即为我们的损失函数$J(	heta)$。其中：
似然函数的代数表达式为：
$$L(	heta) = \prod\limits_{i=1}^{m}(h_{	heta}(x^{(i)}))^{y^{(i)}}(1-h_{	heta}(x^{(i)}))^{1-y^{(i)}}$$
其中m为样本的个数。

对`似然函数对数化取反`的表达式，即损失函数表达式为：
$$J(	heta) = -lnL(	heta) = -\sum\limits_{i=1}^{m}(y^{(i)}log(h_{	heta}(x^{(i)}))+ (1-y^{(i)})log(1-h_{	heta}(x^{(i)})))$$
损失函数用`矩阵法`表达更加简洁：
$$J(	heta) = -Yullet log(h_{	heta}(X)) - (E-Y)ullet log(E-h_{	heta}(X))$$
其中E为单位矩阵$ullet$为内积。

# 二元逻辑回归的损失函数的优化方法
对于二元逻辑回归的损失函数极小化，有比较多的方法，最常见的有`梯度下降法`，`坐标轴下降法`，`等牛顿法`等。
这里推导出梯度下降法中$	heta$每次迭代的公式。
由于代数法推导比较的繁琐，我习惯于用`矩阵法`来做损失函数的优化过程，
这里给出`矩阵法推导二元逻辑回归梯度`的过程。

对于$J(	heta) = -Yullet log(h_{	heta}(X)) - (E-Y)ullet log(E-h_{	heta}(X))$，
我们用$J(	heta)$对$	heta$向量求导可得：
$$rac{\partial}{\partial	heta}J(	heta) = -Y ullet X^Trac{1}{h_{	heta}(X)}h_{	heta}(X)(1-h_{	heta}(X)) + (E-Y)ullet X^Trac{1}{1-h_{	heta}(X)}h_{	heta}(X)(1-h_{	heta}(X)) = X^T(h_{	heta}(X) - Y ) $$
这一步我们用到了矩阵求导的链式法则，和下面三个矩阵求导公式：
* $rac{\partial}{\partial X}logX = rac{1}{X}$
* $rac{\partial}{\partial z}g(z) = g(z)(1-g(z))$，   (g(z)为sigmoid函数)
* $rac{\partial}{\partial	heta}X	heta = X^T$

从而在梯度下降法中每一步向量$	heta$的迭代公式如下：
$$	heta = 	heta - lpha X^T(h_{	heta}(X) - Y )$$
其中，$lpha$为梯度下降法的步长。
实践中，我们一般不用操心优化方法，大部分机器学习库都内置了各种逻辑回归的优化方法，不过了解至少一种优化方法还是有必要的。
　　　　
# 二元逻辑回归的正则化
逻辑回归也会面临`过拟合问题`，所以我们也要考虑正则化。常见的有L1正则化和L2正则化。
逻辑回归的`L1正则化`的损失函数表达式如下，相比普通的逻辑回归损失函数，增加了L1的范数做作为惩罚，超参数$lpha$作为惩罚系数，调节惩罚项的大小。

二元逻辑回归的L1正则化损失函数表达式如下：
$$J(	heta) = -Yullet logh_{	heta}(X) - (E-Y)ullet log(1-h_{	heta}(X)) + lpha||	heta||_1$$
其中$||	heta||_1$为$	heta$的`L1范数`。
逻辑回归的L1正则化损失函数的优化方法常用的有`坐标轴下降法`和`最小角回归法`。

二元逻辑回归的L2正则化损失函数表达式如下：
$$J(	heta) = -Yullet logh_{	heta}(X) - (E-Y)ullet log(1-h_{	heta}(X)) + rac{1}{2}lpha||	heta||_2^2$$
其中$||	heta||_2$为$	heta$的`L2范数`。
逻辑回归的L2正则化损失函数的优化方法和普通的逻辑回归类似。

# 二元逻辑回归的推广：多元逻辑回归
二元逻辑回归的模型和损失函数很容易推广到多元逻辑回归。
* 比如总是认为某种类型为正值，其余为0值，这种方法为最常用的是`one-vs-reset(OvR)`.
* `Many-vs-Many(MvM)`，它会选择一部分类别的样本和另一部分类别的样本来做逻辑回归二分类。
* 最常用的是`One-Vs-One（OvO）`。OvO是MvM的特例。

我们选择两类样本来做二元逻辑回归，具体如下：
首先回顾下二元逻辑回归。
$$P(y=1|x,	heta ) = h_{	heta}(x) =  rac{1}{1+e^{-x	heta}} = rac{e^{x	heta}}{1+e^{x	heta}}$$
$$P(y=0|x,	heta ) = 1- h_{	heta}(x) = rac{1}{1+e^{x	heta}}$$
其中$y$只能取到0和1。则有：
$$lnrac{P(y=1|x,	heta )}{P(y=0|x,	heta)} = x	heta$$
如果我们要推广到多元逻辑回归，则模型要稍微做下扩展。
我们假设是K元分类模型,即样本输出y的取值为1，2，。。。，K。
根据二元逻辑回归的经验，我们有：
$$lnrac{P(y=1|x,	heta )}{P(y=K|x,	heta)} = x	heta$$
$$lnrac{P(y=2|x,	heta )}{P(y=K|x,	heta)} = x	heta$$
$$...$$
$$lnrac{P(y=K-1|x,	heta )}{P(y=K|x,	heta)} = x	heta_{K-1}$$
上面有K-1个方程。
加上概率之和为1的方程如下：
$$\sum\limits_{i=1}^{K}P(y=i|x,	heta ) = 1$$
从而得到K个方程，里面有K个逻辑回归的概率分布。
解出这个K元一次方程组，得到K元逻辑回归的概率分布如下：
$$P(y=k|x,	heta ) =  e^{x	heta_k} igg/ 1+\sum\limits_{t=1}^{K-1}e^{x	heta_t},k = 1,2,...K-1$$
$$P(y=K|x,	heta ) =  1 igg/ 1+\sum\limits_{t=1}^{K-1}e^{x	heta_t}$$
多元逻辑回归的损失函数推导以及优化方法和二元逻辑回归类似

# scikit-learn中的逻辑回归实践
http://www.cnblogs.com/pinard/p/6035872.html

# 逻辑回归的优缺点
逻辑回归尤其是二元逻辑回归是非常常见的模型，训练速度很快，
虽然使用起来没有支持向量机（SVM）那么占主流，但是解决普通的分类问题是足够了，训练速度也比起SVM要快不少。
如果你要理解机器学习分类算法，那么第一个应该学习的分类算法个人觉得应该是逻辑回归。
理解了逻辑回归，其他的分类算法再学习起来应该没有那么难了。

## 优点
* 实现简单，易于理解和实现；计算代价不高，速度很快，存储资源低；
* 实现简单，广泛的应用于工业问题上；
* 分类时计算量非常小，速度很快，存储资源低；
* 便利的观测样本概率分数；
* 对逻辑回归而言，多重共线性并不是问题，它可以结合L2正则化来解决该问题；

## 缺点
* 容易欠拟合，分类精度可能不高
why：数据问题？正负样本不均衡，特征不具代表性?

* 过拟合如何处理
方法一：尽量减少选取变量的数量
方法二：正则化

# 逻辑回归的应用